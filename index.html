<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SNAKE PRO MAX</title>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
    <style>
        :root {
            --grass: #2d5a27;
            --grass-light: #32632c;
            --dirt: #3d2514;
            --wood: #5d4037;
            --paper: #f9f3e3;
            --accent: #cddc39;
        }

        body {
            background-color: #0f1a0f;
            background-image: radial-gradient(#1b301b 1px, transparent 1px);
            background-size: 20px 20px;
            color: #2e1a05;
            font-family: 'Fredoka One', cursive;
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
        }

        #game-wrapper {
            display: flex;
            gap: 40px;
            align-items: center;
            padding: 20px;
        }

        #canvas-area {
            position: relative;
            background: var(--grass);
            border: 12px solid var(--wood);
            border-radius: 30px;
            box-shadow: 0 25px 50px rgba(0,0,0,0.8);
            line-height: 0;
        }

        canvas { display: block; border-radius: 10px; }

        .sidebar {
            width: 240px;
            background: var(--paper);
            border: 6px solid var(--wood);
            border-radius: 24px;
            padding: 25px;
            box-shadow: 8px 8px 0px rgba(0,0,0,0.4);
        }

        .stat-label { font-size: 12px; color: #8d6e63; text-transform: uppercase; margin: 0; letter-spacing: 1px;}
        .stat-value { font-size: 38px; color: #2e7d32; margin-bottom: 25px; }

        .legend-row {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 10px;
            font-size: 14px;
            padding: 8px 12px;
            border-radius: 12px;
            opacity: 0.7;
            transition: 0.3s;
        }

        .legend-row.active {
            opacity: 1;
            background: #fff;
            transform: scale(1.1);
            border: 2px solid var(--row-color);
        }

        .fruit-dot { width: 14px; height: 14px; border-radius: 50%; }

        .screen {
        position: absolute;
        inset: 0;
        background: rgba(15, 26, 15, 0.9);
        backdrop-filter: blur(8px);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 10;
        color: white;
        border-radius: 15px;
        text-align: center;
        /* ADD THIS LINE */
        gap: 30px; 
    }

        .btn {
            background: #f57c00;
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 22px;
            border-radius: 50px;
            cursor: pointer;
            border-bottom: 5px solid #bf360c;
            font-family: inherit;
        }

        .btn:hover { background: #ff9800; }

        #effect-toast {
            position: absolute;
            top: 30px;
            width: 100%;
            text-align: center;
            font-size: 32px;
            pointer-events: none;
            z-index: 5;
            text-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }

        .hidden { display: none !important; }
    </style>
</head>
<body>

<div id="game-wrapper">
    <div id="canvas-area">
        <div id="effect-toast"></div>
        <canvas id="gameCanvas"></canvas>
        
        <div id="start-screen" class="screen">
            <h1 style="font-size: 50px; margin-bottom: 10px;">SNAKE GAME <span style="color:var(--accent)">PRO MAX</span></h1>
            <button class="btn" onclick="startGame()">START</button>
        </div>

        <div id="game-over-screen" class="screen hidden">
            <h1 id="death-msg" style="color: #ff5252; font-size: 36px; margin-bottom: 10px;">CRASHED!</h1>
            <p id="final-score-txt" style="font-size: 24px; margin-bottom: 30px;">Score: 0</p>
            <button class="btn" onclick="startGame()">RETRY</button>
        </div>
    </div>

    <div class="sidebar">
        <p class="stat-label">Score</p>
        <div class="stat-value" id="score">0</div>
        
        <div id="legend">
            <div class="legend-row" data-type="SPEED" style="--row-color: #ff5252"><div class="fruit-dot" style="background:#ff5252"></div> Frenzy</div>
            <div class="legend-row" data-type="SLOW" style="--row-color: #7c4dff"><div class="fruit-dot" style="background:#7c4dff"></div> Sluggish</div>
            <div class="legend-row" data-type="GHOST" style="--row-color: #40c4ff"><div class="fruit-dot" style="background:#40c4ff"></div> Spirit</div>
            <div class="legend-row" data-type="SHRINK" style="--row-color: #ffa726"><div class="fruit-dot" style="background:#ffa726"></div> Shed</div>
            <div class="legend-row" data-type="REVERSE" style="--row-color: #ec407a"><div class="fruit-dot" style="background:#ec407a"></div> Dizzy</div>
            <div class="legend-row" data-type="BOMB" style="--row-color: #212121"><div class="fruit-dot" style="background:#212121"></div> Bomb</div>
        </div>

        <p class="stat-label" style="margin-top:20px">High Score</p>
        <div class="stat-value" id="high-score" style="font-size: 20px;">0</div>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const GRID = 20, TILE = 32;
    canvas.width = canvas.height = GRID * TILE;

    let score = 0, highScore = localStorage.getItem('snake_wild_v7_hi') || 0;
    document.getElementById('high-score').innerText = highScore;

    let snake = [], fruits = [], bombs = [], particles = [];
    let curDir = {x: 1, y: 0}, nextDir = {x: 1, y: 0};
    let isPlaying = false, lastStep = 0;
    let stepSpeed = 150; // Current actual speed
    let baseStepSpeed = 150; // Speed determined by score
    let activeEffect = null, shake = 0;

    const FRUIT_DEFS = {
        SPEED: { color: '#ff5252', msg: 'FRENZY!' },
        SLOW: { color: '#7c4dff', msg: 'SLUGGISH...' },
        GHOST: { color: '#40c4ff', msg: 'SPIRIT WALK' },
        SHRINK: { color: '#ffa726', msg: 'SHEDDING SKIN' },
        REVERSE: { color: '#ec407a', msg: 'DIZZY...' },
        BOMB: { color: '#212121', msg: 'BOMB PLANTED!' }
    };

    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    function playSound(type) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator(), gain = audioCtx.createGain();
        osc.connect(gain); gain.connect(audioCtx.destination);
        const now = audioCtx.currentTime;
        if (type === 'eat') {
            osc.frequency.setValueAtTime(500, now); osc.frequency.exponentialRampToValueAtTime(1000, now + 0.1);
            gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
            osc.start(); osc.stop(now + 0.1);
        } else if (type === 'boom') {
            osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, now);
            osc.frequency.linearRampToValueAtTime(30, now + 0.5);
            gain.gain.setValueAtTime(0.3, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
            osc.start(); osc.stop(now + 0.5);
        }
    }

    function spawnFruit() {
        let attempts = 0;
        while(attempts < 100) {
            let x = Math.floor(Math.random()*GRID), y = Math.floor(Math.random()*GRID);
            const occupied = snake.some(s=>s.x===x && s.y===y) || bombs.some(b=>b.x===x && b.y===y);
            if(!occupied) {
                const types = Object.keys(FRUIT_DEFS);
                fruits.push({ x, y, type: types[Math.floor(Math.random()*types.length)], born: Date.now(), life: 10000, eaten: false });
                return;
            }
            attempts++;
        }
    }

    function startGame() {
        score = 0; document.getElementById('score').innerText = "0";
        snake = [{x:8, y:10, ox:7, oy:10}, {x:7, y:10, ox:6, oy:10}, {x:6, y:10, ox:5, oy:10}];
        curDir = {x:1, y:0}; nextDir = {x:1, y:0};
        fruits = []; bombs = []; particles = []; activeEffect = null; 
        baseStepSpeed = 150; stepSpeed = 150;
        isPlaying = true;
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('game-over-screen').classList.add('hidden');
        for(let i=0; i<3; i++) spawnFruit();
        lastStep = performance.now();
        requestAnimationFrame(loop);
    }

    function loop(t) {
        if (!isPlaying) return;
        const delta = t - lastStep;
        let progress = delta / stepSpeed;
        if (delta >= stepSpeed) { update(); lastStep = t; progress = 0; }
        draw(Math.min(progress, 1));
        requestAnimationFrame(loop);
    }

    function update() {
        curDir = nextDir;
        let head = { x: snake[0].x + curDir.x, y: snake[0].y + curDir.y, ox: snake[0].x, oy: snake[0].y };

        if (activeEffect === 'GHOST') {
            if (head.x < 0) head.x = GRID-1; else if (head.x >= GRID) head.x = 0;
            if (head.y < 0) head.y = GRID-1; else if (head.y >= GRID) head.y = 0;
        } else {
            if (head.x < 0 || head.x >= GRID || head.y < 0 || head.y >= GRID) return die("WALL");
        }

        if (snake.some((s,i) => i>0 && s.x === head.x && s.y === head.y)) return die("SELF");
        
        let bombIdx = bombs.findIndex(b => b.x === head.x && b.y === head.y);
        if (bombIdx > -1) {
            spawnParticles(head.x, head.y, '#ff5722', 40, 12);
            return die("BOMB");
        }

        for(let s of snake) { s.ox = s.x; s.oy = s.y; }
        snake.unshift(head);

        let ate = false;
        for(let f of fruits) {
            if (head.x === f.x && head.y === f.y && !f.eaten) {
                f.eaten = true; ate = true;
                
                // SCORE INCREASE FIXED
                score += 10;
                document.getElementById('score').innerText = score;
                
                // SPEED INCREASE LOGIC
                // Decreases interval by 3ms for every 10 points, min 60ms
                baseStepSpeed = Math.max(60, 150 - (score / 10) * 3);
                
                playSound('eat');
                applyEffect(f.type);
                spawnParticles(f.x, f.y, FRUIT_DEFS[f.type].color, 15, 5);
                break;
            }
        }

        if (!ate) snake.pop();
        fruits = fruits.filter(f => !f.eaten && (Date.now()-f.born < f.life));
        if (fruits.length < 3) spawnFruit();
        bombs = bombs.filter(b => Date.now()-b.born < 12000);
        updateParticles();
    }

    function applyEffect(type) {
        const toast = document.getElementById('effect-toast');
        const def = FRUIT_DEFS[type];
        toast.innerText = def.msg;
        toast.style.color = def.color;
        activeEffect = type;
        
        // Use baseStepSpeed as the foundation for effects
        if (type === 'SPEED') stepSpeed = baseStepSpeed * 0.5;
        else if (type === 'SLOW') stepSpeed = baseStepSpeed * 1.6;
        else stepSpeed = baseStepSpeed;
        
        if (type === 'BOMB') bombs.push({x: Math.floor(Math.random()*GRID), y: Math.floor(Math.random()*GRID), born: Date.now()});
        if (type === 'SHRINK' && snake.length > 3) snake = snake.slice(0, Math.floor(snake.length/2)+2);
        
        document.querySelectorAll('.legend-row').forEach(r => r.classList.toggle('active', r.dataset.type === type));
        clearTimeout(window.effT);
        window.effT = setTimeout(() => { 
            activeEffect = null; 
            stepSpeed = baseStepSpeed; 
            toast.innerText = ""; 
            document.querySelectorAll('.legend-row').forEach(r => r.classList.remove('active'));
        }, 7000);
    }

    function die(reason) {
        isPlaying = false; shake = 40;
        playSound('boom');
        const msg = document.getElementById('death-msg');
        if (reason === "WALL") msg.innerText = "SMACKED THE BORDER!";
        else if (reason === "SELF") msg.innerText = "OUCH! BIT YOURSELF!";
        else msg.innerText = "BOOM! BLASTED!";
        
        if (score > highScore) { highScore = score; localStorage.setItem('snake_wild_v7_hi', score); document.getElementById('high-score').innerText = score;}
        document.getElementById('final-score-txt').innerText = `Score: ${score}`;
        document.getElementById('game-over-screen').classList.remove('hidden');
    }

    function draw(p) {
        ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.save();
        if (shake > 0) { ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake); shake *= 0.8; }
        
        ctx.fillStyle = '#2d5a27'; ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = '#32632c';
        for(let i=0; i<GRID; i++) for(let j=0; j<GRID; j++) if((i+j)%2===0) ctx.fillRect(i*TILE, j*TILE, TILE, TILE);

        const now = Date.now();
        bombs.forEach(b => {
            const x = b.x*TILE+16, y = b.y*TILE+16;
            ctx.fillStyle = '#212121'; ctx.beginPath(); ctx.arc(x,y,12,0,Math.PI*2); ctx.fill();
            ctx.fillStyle = '#424242'; ctx.beginPath(); ctx.arc(x-4,y-4,3,0,Math.PI*2); ctx.fill();
            ctx.fillStyle = Math.sin(now/50)>0 ? '#ffeb3b' : '#f44336';
            ctx.beginPath(); ctx.arc(x+12,y-12,Math.random()*4+2,0,Math.PI*2); ctx.fill();
        });

        fruits.forEach(f => {
            const age = now - f.born, remaining = f.life - age;
            let scale = age < 500 ? age / 500 : (remaining < 1000 ? remaining / 1000 : 1);
            const x = f.x*TILE+16, y = f.y*TILE+16 + Math.sin(now/150)*4;
            ctx.save(); ctx.translate(x, y); ctx.scale(scale, scale);
            ctx.fillStyle = FRUIT_DEFS[f.type].color; ctx.beginPath(); ctx.arc(0,0,10,0,Math.PI*2); ctx.fill();
            ctx.fillStyle = '#8bc34a'; ctx.beginPath(); ctx.ellipse(4,-9,6,3,Math.PI/4,0,Math.PI*2); ctx.fill();
            ctx.restore();
        });

        snake.forEach((s, i) => {
            let dx = s.x - s.ox, dy = s.y - s.oy;
            if (dx > 1) dx -= GRID; else if (dx < -1) dx += GRID;
            if (dy > 1) dy -= GRID; else if (dy < -1) dy += GRID;
            const curX = (s.ox + dx * p) * TILE, curY = (s.oy + dy * p) * TILE;
            ctx.globalAlpha = activeEffect === 'GHOST' ? 0.6 : 1.0;
            ctx.fillStyle = i === 0 ? '#cddc39' : '#8bc34a';
            const size = TILE-4-(i*0.5);
            ctx.beginPath(); ctx.roundRect(curX+(TILE-size)/2, curY+(TILE-size)/2, size, size, i===0?12:8); ctx.fill();
            if (i === 0) {
                const lx = dx || curDir.x, ly = dy || curDir.y;
                const drawEye = (ox, oy) => {
                    const ex = curX+16+ox, ey = curY+16+oy;
                    ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(ex, ey, 5, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(ex + lx*2, ey + ly*2, 2.5, 0, Math.PI*2); ctx.fill();
                };
                if(lx !== 0) { drawEye(lx*8, -7); drawEye(lx*8, 7); } else { drawEye(-7, ly*8); drawEye(7, ly*8); }
            }
        });

        particles.forEach(pt => {
            ctx.globalAlpha = pt.l; ctx.fillStyle = pt.c;
            ctx.beginPath(); ctx.arc(pt.x, pt.y, pt.s, 0, Math.PI*2); ctx.fill();
        });
        ctx.restore();
    }

    function spawnParticles(x, y, color, count, speed) {
        for(let i=0; i<count; i++) particles.push({ x:x*TILE+16, y:y*TILE+16, vx:(Math.random()-0.5)*speed, vy:(Math.random()-0.5)*speed, l:1, c:color, s:Math.random()*4+2 });
    }

    function updateParticles() {
        for(let i=particles.length-1; i>=0; i--) {
            particles[i].x += particles[i].vx; particles[i].y += particles[i].vy; particles[i].l -= 0.03;
            if(particles[i].l <= 0) particles.splice(i,1);
        }
    }

    window.addEventListener('keydown', e => {
        const k = e.key.toLowerCase();
        let m = null;
        if (k === 'arrowup' || k === 'w') m = {x:0, y:-1};
        else if (k === 'arrowdown' || k === 's') m = {x:0, y:1};
        else if (k === 'arrowleft' || k === 'a') m = {x:-1, y:0};
        else if (k === 'arrowright' || k === 'd') m = {x:1, y:0};
        if (m) {
            if (activeEffect === 'REVERSE') { m.x *= -1; m.y *= -1; }
            if (m.x !== -curDir.x || m.y !== -curDir.y) nextDir = m;
        }
    });
</script>
</body>
</html>
